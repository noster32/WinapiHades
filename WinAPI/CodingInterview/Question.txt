※ 이력서/자기소개서 작성이 안 된 상태라 주의점과 방어 멘트 / 면접 요령은 차후


- 기술 면접 -

♥ : 연봉오르는 질문


01. 절차지향과 객체지향의 차이?
 ㄴ 절차지향은 코드가 구조적이지 못하고 흩어져있어 유지 보수가 어렵다는 단점이 있습니다.
    객체지향은 코드의 기준을 "객체" 단위로 묶어 프로그래밍하는 방식을 의미합니다. 객체지향 기법에는 
    상속이나 다형성 등 다양한 개념이 존재.


02. 객체지향 4대 특징은?
 ㄴ 캡슐화, 다형성, 추상화, 상속 + 알파로 내용도 간단히 말하기


03. 객체지향 5대 설계 원칙
 ㄴ 단일책임의원칙(SRP), 개방폐쇄원칙(OCP), 인터페이스분리원칙(ISP), 리스코프치환원칙(LSP), 의존역전원칙(DIP)


04. 메가맨 해봤는지? 혹은 유사한 플랫포머 장르의 충돌처리는 어떻게 할지? 본인의 의견을 제시해라.
 ㄴ 픽셀충돌과 렉트충돌(IntersectRect)을 주로 사용했습니다. 픽셀충돌은 단점으로 예외처리를 잘 해야 했지만, 
    장점으로 경사가 있는 지형에서 사용하기 좋았습니다. AAB/OBB


05. 디자인 패턴에 대해 아는가? 왜 사용해야 하는가?
 ㄴ 디자인 패턴은 프로그램을 개발하는 과정에서 빈번하게 발생하는 디자인 문제를 정리해서 상황에 따라 
    간편하게 적용할 수 있게 정리한 것입니다. 예시로 싱글톤.


06. 입사동기 (왜 널 뽑아야 하는지? 어필해보시오)
 ㄴ ???


07. 야근 여부와 의지?
 ㄴ 회사의 요청이 있다면, 회사에 속한 소속원으로 야근하는데 전혀 무리가 없습니다.


08. 자기보다 나이가 어린 사람 아래서 일할 수 있는지?
 ㄴ 부당한 상황 부여와 텃세에 대해서는 어떻게 생각하는지?


09. 외국어 할 줄 아는지?
 ㄴ 과한 거짓말 절대 금지!


10. 읽고 있는 전공책은?
 ㄴ 언어는 이펙티브 C++/C# 시리즈. OS 관련은 공룡책.
    일반 나머지는 골프책(디자인 패턴), 용책(다이렉트), 해골책(다이렉트), 
    물방울책(다이렉트), 노을책(dx12)(다이렉트).


11. 앱실론에 대해 알고 있는지?
 ㄴ 부동 소수점은 실수를 정확기 표현할 수 없는 문제를 가지고 있어서 정확한 계산을 위해서 
    상수로 정의된 값을 사용하는 것.


12. 모두 퇴근하고 혼자 남은 상황에서 문제점을 발견했다. 본인의 판단은?
 ㄴ 개발 중인 게임은 클라이언트 팀장에게 보고. 라이브 운영 중인 게임은 서버에게 연락. 
    본인의 문제라면 해결하려 노력이 필요. 이 이상 윗선에게는 보고 X. 어차피 잘 모름.


13. 어떤 걸 중점적으로 붙들고 공부해봤는가?
 ㄴ 본인만의 어필요소를 강조해야 한다.


14. 동료와 의견차이가 있을 때 어떻게 처리할 것인지?
 ㄴ 최대한 긍정적인 내용으로 포장하여 얘기해야 한다.


15. 메모리 구조에 대해서 설명해보시오
 ㄴ ▷ 코드 영역
	  - 실행할 코드가 저장되는 메모리 공간이며 CPU는 코드 영역에 저장된 명령문들을
	    하나씩 가져가서 실행함.
	  - 코드 영역은 기본적으로 운영체제에 의해 관리되기에 직접적으로 대화하는 것은 원칙적으로는 불가능함.
	    (C++언어는 가능. 메모리 접근 권한과 컴파일러 덕분.)

	 ▷ 데이터 영역
	  - 전역 변수와 static으로 선언되는 static 변수가 할당되는 공간.
	  - 프로그램 시작과 동시에 메모리 공간에 할당되어 프로그램 종료 시까지 남아있음.
	  - 전역 변수, 정적 변수 등 프로그램이 실행될 때 할당되고 종료될 때 제거되는 영역이라고 할 수 있음.

     ▷ 스택 영역 (메모리 스택과 STL 스택이 있고, 지금은 메모리 스택을 얘기 함.)
	  - 지역변수와 매개변수가 할당, 선언된 함수를 빠져나가면 소멸.
	  - 시스템에 의해서 관리되는 영역.
	  - Main 함수를 시작으로 아래에서부터 위로 쌓임. 선입후출.
	  - 함수가 들어가면 컴파일러에게 함수 주소값을 던짐.
	  - 스택의 최대 사이즈는 약 1Mb. 스택 오버 플로우 안 나오게 조심.

	 ▷ 힙 영역
	  - 프로그래머에 의해서 관리되는 영역. (동적 메모리 영역)
	  - 데이터 영역과 스택 영역에 할당되는 변수들은 생성과 소멸 주기가 정해져 있음.
	  - 하지만 프로그래머가 원하는 시점에 변수를 할당하고 소멸할 수 있는 영역이 바로 힙.
	  - 특징으로는 프로그래머가 직접 할당을 하기에 프로그래머가 직접 소멸을 시켜야 함.
	  - 삭제를 해주지 않으면 메모리에 계속 상주함.
	  - 삭제를 안 하면 결국 메모리릭, 댕글링포인터 발생.
       ㄴ 프로그램이 종료될 때 소멸을 시켜주긴 함.
	  - 특정 함수나 변수가 필요할 때 스택 영역에서 자세히 모두 불러 옴.
	  - 임시 메모리 영역에서 삭제 등이 필요할 때 포인터로 가능.


16. C / C++의 차이점
 ㄴ 순차적인지 객체지향인지 차이. STL 라이브러리의 유뮤. mulloc과 new 차이. free와 delete 차이.
    C++은 new로 할당 시 생성자를 호출.

 ㄴ 순차적 프로그래밍 (C는 절차지향)
   ㄴ 가장 초기부터 사용된 기법으로 코드의 흐름에 따라 프로그래밍 하는 기술.
   ㄴ 요약을 하면 프로그램의 실행부터 종료까지 흐름을 그대로 프로그래밍 함.
   ㄴ 구조적이지 못하고 코드가 흩어져있어 유지 보수가 어렵다는 단점이 있음.

 ㄴ 객체지향 프로그래밍(OOP: Object Oriented Programming)
   ㄴ 위의 두 방식과는 전혀 다른 방식으로 코드의 기준을 "객체" 단위로 묶어 프로그래밍하는 방식을 의미.
   ㄴ 모든 대상에는 속성과 메서드가 있고 이를 하나로 묶어 객체로 만드는 방식.
   ㄴ 여기에서 말하는 대상에는 눈에 보이지 않는 것들도 포함이 됨.
   ㄴ 객체지향 기법에는 상속이나 다형성 등 다양한 개념이 존재.


16-1. C 언어와 나머지 언어의 차이점
ㄴ



17. C++을 왜 공부해야 하는가? ★★★★★★★★★★
 ㄴ 메모리 구조에 유리, 통합개발환경(IDE)에 적합한 언어, 컴파일러가 있기 때문(컴파일 후 오류 확인도 가능).
 ㄴ 지나치게 범용적이기 때문에 무겁고, 메모리 소모량이 크다. 컴파일러가 이런 단점에 일조한다.


18. ZeroMemory vs. Memset
 ㄴ ZeroMemory는 첫 번째 인자가 가리키는 주소의 값을 0으로 초기화. 
    Memset은 0이 아닌 다른 것으로도 초기화 가능.


19. 상속의 장점은?
 ㄴ 부모 클래스의 변수 등을 재사용할 수 있어 개발 시간이 단축됩니다.
    그리고 클래스 간 계층 관계가 명확해져서 유지보수가 용이합니다.


20. 다중 상속을 최대한 사용하지 말아야 하는 이유?
 ㄴ 한 눈에 안 보이는 복잡함이 발생할 수 있습니다. 프로그래머에 의한 실수가 발생할 확률이 높아집니다.
    다만, 최하위 클래스가 중단 단계 클래스의 기능을 받아오기 좋은 강점이 있습니다. 여기서 최하위 클래스라는 
	조건이 필수입니다.
    ※ 참고: C++11에서 추가된 프렌드라는 기능이 있음. 이는 단방향 소통.


21. 가상 함수란 무엇인가? 어떨 때 사용을 해야 하는가? 왜 써야 하는가?
 ㄴ 부모 클래스의 특정 함수가 자식 클래스에 재정의 되었을 경우 부모 클래스의 참조 또는 포인터를 가지고 
    자식 클래스의 특정 함수를 실행시키는 메커니즘을 뜻합니다. 객체의 계층 구조에 따라 자식 클래스의 
	특정 함수를 호출하는 것이 가능하기에 상속과 함께 자주 쓰입니다.


22. 가상 함수의 키워드 동작 방식
 ㄴ virtual 키워드입니다. 오버라이딩 되지 않는다면, 호출 시 부모 클래스의 함수가 호출되고, 오버라이딩 되었다면 
    함수 호출 시 자식 클래스의 함수가 호출되는 매커니즘을 가지고 있습니다.


23. 가상 함수의 멤버 함수란?
 ㄴ virtual 키워드를 붙이는 원형 함수를 의미합니다.
    ※ 참고: 확실하지 않음. 더 찾아야 함.


24. 가상 함수의 테이블에 대해 설명해 보시오.
 ㄴ 컴파일러는 각각의 객체마다 가상 함수 테이블을 가리키는 포인터를 저장하기 위한 숨겨진 멤버를 하나씩 추가합니다.
    이와 함께 가상 함수를 단 하나라도 가지는 클래스에 대해서 가상 함수 테이블을 작성합니다. 이렇게 작성된 
	가상 함수 테이블에는 해당 클래스의 객체들을 위해 선언된 가상 함수들의 주소가 저장되게 됩니다.
    ※ 참고: 가상 함수가 호출됐을 때 원본 함수와 자식 함수가 체결되면서 어떻게 가상화가 되는지 여부.
	        그림판에서 화살표로 그려보면 이해가 빠름.


25. 코딩 테스트: 문자열 관련
 ㄴ 로직이 간결함. 논리를 확인하기 좋음.
 ㄴ 펄어비스
 <주의 사항> C++언어로 풀어야 하고 아래의 빈칸을 알맞게 채워 놓으시오. (빈칸에 코딩)
 C 런타임 라이브러리나 STL 등 기타 라이브러리 함수를 사용하면 안됩니다.
 특히 STL String을 사용 시 바로 탈락 처리가 되니 유의 바랍니다.
 그리고 해당 방법에 대해 왜 그렇게 기입을 했는지 짧은 주석을 넣어 주세요.

 문제 1. 주어진 문자열을 단어 단위로 순서를 뒤집어 출력하세요.
 <예>
 입력값: "Hello World this is Pearl Abyss"
 반환값: "Pearl Abyss is this World Hello"
 <조건>
 입력 문자열은 앞뒤에 공백이 없다고 가정합니다.
 모든 단어는 공백 한 칸으로 구분된다고 가정합니다.
 void ReverseWords(char* output, int outputArraySize, const char* input)
 {
	// 이곳을 채워 넣으세요.
 }


26. 문자열 회문(回文, level) 인지 파악
 ㄴ 본인은 어떻게 처리할 것인지?
 문자열 맨 앞과 맨 뒤부터 한칸씩 비교를 해본다


27. 밸류 타입과 레퍼런스 타입에 대해 설명하시오.
 ㄴ Call By Value. 값의 전달(Data). int Add(int a, int b);
 ㄴ Call By Reference. 주솟값의 전달. int Add(int* a, int* b);
 ㄴ 벨류 타입은 변수에 저장하는 변하지 않는 데이터이고,
레퍼런스 타입은 변할 수 있는 데이터이다.

28. WinAPI 메시지 루프에는 어떤 게 있는가?
동기 vs 비동기를 말해주면 좋다
 ㄴ PeekMessage: 주기적 진동. GetMessage: 필요할 때만 진동.
 ㄴ GetMessage(): 필요할때만 진동을 하는가
GetMessage() 함수는 Message Queue 에서 메세지를 가져오고, 가져온 뒤 그 메세지를 Message Queue 에서 삭제한다.
이 함수가 가져오는 메세지는 오직 이 함수를 호출한 프로그램과 관련된 메세지만 가져온다.

ㄴ PeekMessage(): 주기적으로 진동을 하는가
메세지가 존재하든 존재하지 않든 Message Queue의 가장 밑(즉, 다음 GetMessage()로 인해 가져오게 되는 메세지) 부분을 볼 수 있다.
메세지가 있으면 TRUE, 없으면 FALSE 를 반환하고, 만약 메세지가 있으면 그 메세지를 MessageQueue에서 제거할지 유지할지 선택할 수 있다.


29. API 정의에 대해 설명하시오.
 ㄴ Application Programming Interface.
 ㄴ 운영체제가 같으면 같은 기능의 집합을 사용하기에 확장성 및 연동성, 그리고 유지보수가 편리하기 때문입니다.
 ㄴ API를 사용하면 구현 방식을 알지 못하는 제품 또는 서비스와도 통신할 수 있으며 애플리케이션 개발을 간소화하여 시간과 비용을 절약할 수 있습니다. 
새로운 툴과 제품을 설계하거나 기존 툴과 제품을 관리할 때 API를 사용하면 유연성을 높이고 설계, 관리, 사용 방법을 간소화하며 혁신의 기회를 얻을 수 있습니다.


30. 스택과 힙의 차이점은?
 ㄴ 동적과 정적의 차이가 큼.
 
     ▷ 스택 영역 (메모리 스택과 STL 스택이 있고, 지금은 메모리 스택을 얘기 함.)
	  - 지역변수와 매개변수가 할당, 선언된 함수를 빠져나가면 소멸.
	  - 시스템에 의해서 관리되는 영역.
	  - Main 함수를 시작으로 아래에서부터 위로 쌓임. 선입후출.
	  - 함수가 들어가면 컴파일러에게 함수 주소값을 던짐.
	  - 스택의 최대 사이즈는 약 1Mb. 스택 오버 플로우 안 나오게 조심.

	 ▷ 힙 영역
	  - 프로그래머에 의해서 관리되는 영역. (동적 메모리 영역)
	  - 데이터 영역과 스택 영역에 할당되는 변수들은 생성과 소멸 주기가 정해져 있음.
	  - 하지만 프로그래머가 원하는 시점에 변수를 할당하고 소멸할 수 있는 영역이 바로 힙.
	  - 특징으로는 프로그래머가 직접 할당을 하기에 프로그래머가 직접 소멸을 시켜야 함.
	  - 삭제를 해주지 않으면 메모리에 계속 상주함.
	  - 삭제를 안 하면 결국 메모리릭, 댕글링포인터 발생.
       ㄴ 프로그램이 종료될 때 소멸을 시켜주긴 함.
	  - 특정 함수나 변수가 필요할 때 스택 영역에서 자세히 모두 불러 옴.
	  - 임시 메모리 영역에서 삭제 등이 필요할 때 포인터로 가능.

ㄴ 프로그래머가 직접 관리 하냐 안하냐의 차이점
ㄴ 스택은 정적 메모리, 힙은 동적 메모리이다.
스택:  함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역
스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸
스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출됩니다.

힙: 사용자가 직접 관리할 수 있는 ‘그리고 해야만 하는’ 메모리 영역
힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제
malloc/free | new/delete

31. 구조체와 클래스의 차이
ㄴ C/C++과 C#의 구조체 클래스는 엄청 다르기 때문에
	어떤 언어에 대한 구조체와 클래스의 차이를 물어보는지 한번 물어봐야한다.
ㄴ C/C++ 에서 구조체와 클래스의 차이
   -> 접근 제어 지시자의 차이 구조체는 public, 클래스는 private
ㄴ C#에서는 가비지 컬렉션을 호출함. 이 차이가 있음.


32. 다른 사람의 코드를 보고 해석하는 능력이 어느정도 된다고 생각하는지?
ㄴ 

★★★★
33. 프로그램을 하면서 어느 위치까지 가는것이 목표인가?
ㄴ 자기만의 게임을 개발하고싶다 -> 광탈, 절대안됨
ㄴ 1. 직급을 통해서 언급 -> 갈 최종 테크트리 언급 -> PD
	-> 엔진팀(기업규모가 커야 있는 팀), 최적화팀(가장 피해야 하는 팀, 32번 아주 중요함), 셰이더, : 연봉 탑3 추천x
	-> UI(신입때 하기 가장좋은 팀, 팀장등을 하기 위해 반드시 거쳐야하는 팀),
	-> 이펙트/파티클, 사운드, 플/적, 로딩, 맵, 리소스


ㄴ 2. 내가 해야될 업무를 통해서 언급 -> 실제 하고 싶은 업무 얘기 -> 클라 or 서버
	-> PD, 팀장, 이사 를 하려면 서버가 필수요소

34. 컴퓨터를 구성하고 있는 하드웨어와 특징에 대해 설명 하시오.
ㄴ RAM - 메모리, CPU - 연산, VGA(GPU) - , (+ 들이 OS에서 어떻게 동작하는지)
ㄴ GPU 가 요즘 가장 중요한 추세

CPU는 컴퓨터에서 실행되는 프로그램의 모든 정보를 처리하는 역할을 담당한다. 고성능 타이머의 클록속도가 CPU에 의해 결정된다.
ㄴ 프로그램의 명령어를 해석하여 데이터를 연산/처리를 하고 그렇게 돌아가도록 제어해주는 부분, 혹은 그 기능을 내장한 칩을 의미한다

RAM은 Random Access Memory로 프로그램에 의해 생성된 정보를 그떄마다 일시적으로 저장하고
이 데이터에 즉시 엑세스할 수 있도록 하는 특징이 있다. RAM을 필요로하는 작업으로는 그래픽
디자인을 위한 이미지 렌더링, 동영상 또는 사진 편집, 멀티태스킹 등이 있다.
ㄴ 사용자가 자유롭게 내용을 읽고 쓰고 지울 수 있는 기억장치. 컴퓨터가 켜지는 순간부터 CPU는 연산을 하고 동작에 필요한 모든 내용이 전원이 유지되는 내내 이 기억장치에 저장된다
ㄴ RAM의 용량이 클수록 더 많은 양을 동시에 기록하고 연산하는 것이 가능하다.

GPU는 그래픽 처리 장치로 엄청난 양의 그래픽 데이터를 처리하는 역할을 한다.
이뿐만 아니라, 최신 GPU는 렌더링을 뛰어넘어 폭넓은 연산 워크로드를 처리하여 중앙처리장치를 보완하는 역할도 한다.
ㄴ3D 그래픽을 표현하기 위한 복잡한 절차인 '그래픽 파이프라인'을 거쳐야 하는데, 이것들을 모두 수행하려면 단순 픽셀 채우기랑은 비교가 안 될 정도의 요구 사양이 필요하다.
그렇다 보니 GPU의 기능이 복합적일 수밖에 없고, CPU의 명령을 받아서 발행하는 커맨드 프로세서, 명령들을 각각의 연산 코어들에게 적절하게 스케줄링 및 분배해줄 디스페치,
지오메트리 처리를 위한 버텍스 인출, 버텍스 셰이딩 연산, 카메라 변환, 투영, 조명, 클리핑, 뷰포트 변환, 스트림 출력, 픽셀 단위로 바꿔줄 래스터라이제이션, 
텍셀 단위로 매핑/어드레싱하고 필터링해줄 텍스처링, 픽셀 단위로 색을 연산해줄 픽셀 셰이딩 연산, 블렌딩이나 안티에일리어싱 및 기타 후처리에 관여해줄 렌더링까지 모두 GPU 안에 들어 있다.

★★★
35. 시스템 메모리 / 비디오 메모리 / AGP 메모리 각각 설명해 보시오
ㄴ 시스템 메모리: 
ㄴ 비디오 메모리: 
ㄴ AGP 메모리: 2가지 -> 그래픽 인터페이스 or 알파값

ㄴ 시스템 메모리: 그래픽 카드에서 읽어오려면 CPU를 거쳐 PCI 버스를 통해 통신을 하기에 속도도 느리고 
번거로운 작업을 거쳐야 한다는 단점이 있다.
ㄴ 비디오 메모리: 그래픽 카드내에서 gpu와 보조를 맞추면서 gpu가 처리하는 그래픽 데이터를 임시 저장하는 영역.
상대적으로 쓰기 속도가 느려 잦은 쓰기 작업에는 적합하지 않다.
ㄴ AGP(Accelerated Graphics Port): 시스템 메모리의 일부분을 그래픽 카드에서 바로 사용하기 위해 BIOS에서 임의로 할당한 영역.
빠른 쓰기 작업이 가능. CPU 사용량이 많아지면 덩달아 효율이 떨어지게 된다. 주변 기기와의 간섭이 적어 효율적인 운영 가능.
AGP는 평범한 보통 PC에서 3차원 그래픽표현을 빠르게 구현할 수 있게 해주는 버스 규격으로서, 웹사이트나 CD-ROM상의 3차원 이미지들을 
오늘날의 어떠한 고가의 그래픽 워크스테이션보다도 더 빠르고 부드럽게 전달하기 위해 설계된 특별한 인터페이스이다. 이 인터페이스는 
모니터 이미지를 재생하기 위해 컴퓨터의 램을 사용하며, 3차원 이미지 표현을 위한 질감 맞추기, z-buffering 그리고 알파 블렌딩 등을 지원한다. 
AGP가 메인 메모리를 사용하는 것은 지극히 동적(動的)인데,
이는 그래픽 가속을 위해 메인 메모리를 사용하지 않는 경우에는 운영체계나 다른 응용프로그램에 의해 사용되도록 복원된다는 것을 의미한다.

★★★★
36. 전역, 지역, 동적 변수 등 변수의 LifeCycle 설명해 보시오.
https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=eludien&logNo=221462352935
ㄴ LifeCycle 의 동작 방식(고정) : Allocate -> Release -> Memory Pool
ㄴ 전역: 
	코드 수준: 전 영역에 종속된다
	메모리 수준: 1. 사용하는 순간 전체 가용 메모리에서 원하는 메모리만큼 Allocate 시킨다
				2. 사용하다가 코드가 종료되면 Release 되면서 할당받은 메모리를
				3. 다시 Memory Pool 로 반환시킨다

ㄴ 지역: 
	코드 수준: 스코프 영역({})에 종속된다
	메모리 수준: 1. 사용하는 순간 전체 가용 메모리에서 원하는 메모리만큼 Allocate 시킨다
				2. 사용하다가 코드 영역에서 스코프 영역이 종료되면 Release 되면서 할당받은 메모리를
				3. 다시 Memory Pool 로 반환시킨다
ㄴ 동적: 
	코드 수준: 포인터(*)에 종속된다
	메모리 수준: 1. 포인터(*) 를 사용해서 heap 영역을 가리켜 런타임 시간에 해당 공간을 Allocate 받는다
				2. 사용하다가 delete를 만나 종료되면 Release 되면서 할당받은 메모리를
				3. 다시 heap 영역의 Memory Pool 로 반환시킨다

37. SVN 써봤는지? 안써봤다면 왜 사용을 안했는지? (SVN 의 장단점)
ㄴ Github 과 SVN 의 장단점을 나열하면서 왜 사용을 안한지 설명

- SVN 은 보통 대부분의 기능을 완성해놓고 소스를 중앙 저장소에 Commit 한다.
ㄴ 깃과 가장큰 차이점으로는 개발자가 자신만의 version history를 가질 수 없다.
 그렇기 때문에 local History를 이용하긴 하지만 일시적이기 때문에 이전에 작업했던 내역을 확인 가능하지만 버전 관리가 되진 않는다.
- 또한 commit한 내용에 실수가 있을 시에 다른 개발자에게 바로 영향을 미치게 되는 단점도 있다.


- Git은 매우 빠른 속도와 분산형 저장소로 SVN 보다 많은 기능을 지원하고 있다.
- SVN과 가장큰 차이점으로 git은 자신만의 commit history를 가질 수 있고, 개발자와 서버의 저장소는 독립적으로 관리가 가능하다.
- 또한 commit한 내용에 실수가 있더라도 바로 서버에 영향을 미치지 않는다.

SVN과 Git의 차이점
- Git은 분산형 관리 시스템 SVN은 Client/Server 타입이고, 중앙 서버에 소스코드와 히스토리를 저장
- 그렇기 때문에 깃은 중앙 서버에 장애가 발생해도 로컬 저장소에 커밋을 할 수 있으며,
로컬 저장소들을 이용하여 중앙 저장소의 복원도 가능하다.
- 사본을 로컬에서 관리하기 때문에 Git이 SVN에 비해 훨씬 빠르다.


★★★★★★★★★★★★★★★★★
38. 공동작업(협업)을 해봤을때 본인이 생각한 장/단점 (사골문제)
ㄴ 협업을 하면 장점으로는 자신이 맡은 바에 대해서 혼자 할때보다 좀 더 집중적으로 코드를 작성할 수 있다는 것이
장점이라고 생각합니다.

ㄴ 단점으로는 코딩 규약을 만들어야 하는데 평소에 습관이 들었던 코딩작성법을
고치기가 힘들었다는것이 단점이라고 생각합니다.

39. 협업을 해본 경험 중 좋은점과 나쁜점을 객관적으로 대답 (38번과 세트문제)
ㄴ 

♥ 
40. 가상함수 테이블을 만들 때 메모리상에서 일어나는 과정을 설명해 보시오
ㄴ 런타임 / 동적할당

ㄴ 1. 가상함수가 체결될 때: 런타임 시간에 체결된다
ㄴ 2. 가상함수에서는 동적할당이 발생할까 안할까: 런타임에서 동적할당이 발생한다.

=> 런타임시 동적할당이 되므로 시작시에는 같은 함수를 가리키고 있다가 런타임시 맞는 함수로 동적할당이된다.
( => 일반함수는 정적결합이기 때문에 시작시 스택에 할당되어 있다가 호출하면 가져온다. )

★★★★★★
41. STL 벡터와 리스트의 차이점
ㄴ 리스트는 삽입 삭제가 벡터보다 매우 용이해서 자주 삭제 추가되는 파일들은 리스트로 관리하는게 효율적이다.

- 벡터는 각 요소를 메모리에 연속적으로 저장하기 때문에
 끝이 아닌 곳에서의 삽입 삭제에는 용이하지 않지만 원소의 인덱스로 접근이 가능하며 
개별 원소들을 빠르게 접근 가능하다
- 리스트는 각 요소마다 개별적으로 주소를 할당 받기 때문에 
어느 위치에서든 요소의 삽입 삭제가 빠르게 일어난다.
하지만 원소의 인덱스로 직접 접근은 불가능 하고 원소 순회는 forward / reverse만 가능하기 때문에 느리다
데이터가 빈번하게 바뀜 -> 리스트
벡터는 순차적 주소 리스트는 무작위 주소

42. STL 벡터에 처음 할당된 메모리 이상의 데이터가 들어갔을때 어떻게 되는지 알고 있는가?
ㄴ 오류 메세지들...
ㄴ resize() 로 벡터의 사이즈를 다시 계산해주면서 오류를 해결할 수 있다.
ㄴ 포인터 접근은 쓰레기값이 없어서 터진다. -> vector out of range 오류메세지가 출력된다.

♥
43. push_back / emplace_back 차이점에 대해서 설명해 보시오.
ㄴ 안정성과 속도, 메모리 사용량의 차이가 존재

|0|1|
push_back(2): |0|1| |2| : 인덱스를 2개 잡아주고 유효성 검사가 끝날때까지 대기
				   ㄴ 인덱스 주소에 대한 유효성 검사
유효성 검사를 통과하면 앞으로 밀어준다
-> |0|1|2|

push_back(3): |0|1|2| |3| 
ㄴ 유효성검사 후 |0|1|2|3|

=> push_back은 유효성 검사라는 절차가 존재한다.
	ㄴ 뭔가가 메모리 상에서 발생한다. -> 데이터가 많아지면 속도면에서 불리하다.

|0|1|
emplace_back -> 2, 3
|0|1|NULL|NULL|NULL|... nullptr 이라는 공간을 만들어둠
|0|1|2|3|NULL|... 더 들어올 데이터가 없으면 뒤를 밀어버림
|0|1|2|3|

=> 유효성 검사라는 절자가 존재하지 않음
	ㄴ 속도면에서 빨라지지만 몇개의 데이터가 들어올지 모르기 때문에 데이터 사용량이 커진다.


44. 전방선언 vs 전처리기문 #include 차이점

클래스 안에있는 데이터를 전부 보고싶으면 #include
클래스 안에있는 데이터 일부(특정객체)를 보고싶으면 전방선언

- #include를 많이 할 경우 전처리기 단계가 길어지게 되므로 컴파일 시간이 증가한다.
- 이를 해결하기 위해 전방선언을 지원한다.

=> 불필요한 #include를 피하기 위해 클래스를 전방 선언할 수도 있다.

- 전방 선언은 보통 아래 두 가지 조건에 한에서 사용한다.
ㄴ 1. 클래스의 포인터 / 참조 형식으로 이름만 참조할 경우
ㄴ 2. 매개 변수나 리턴 타입을 위한 이름만 참조할 경우

- 전처리기 -> 컴파일러 -> 링커 순서로 코드를 읽어들이기 때문에
 cpp에 #include를 하지 않으면 링커에서는 해당 클래스를 모르기 떄문에 오류가 발생한다.
=> 따라서 클래스 전방선언을 할경우 반드시 cpp파일에 #include 를 해야한다.


44-1. #define vs Partial (파트리얼) 클래스
Partial 클래스 -> 클래스를 분할하는 키워드 (C# 에서 많이 사용하고, C++에서는 포인터를 사용하면 되기 때문에 사용하지 않아도된다.)


45. 알파블랜딩이란?
ㄴ 알파라는 변수를 이용해서 투명도를 조절하는 것

45번과 세트문제
46. 모바일 게임을 개발한다고 가정을 했을때 반복문 / 리소스 처리 / 알파값 중 가장 부하가 많이 발생하는 부분은 어디인가?
ㄴ 투명도가 들어올때 부하가 많이 발생
ㄴ 3D의 경우 앞 뒤 옆 구분을 할 수 없기 때문에 컴퓨터 게임에서는 플레이어가 물체를 바라보는 방향과 물체가 플레이어를 바라보는 방향을 계산해서 같으면 앞이라고 판단해주는 연산을 하지만
모바일게임의 경우 그런 연산을 할 스펙이 안되기 때문에 보통 뒤의 물체들의 알파값을 낮추는 것이 보통이다.
ㄴ 계속 알파값을 조절하기 때문에 알파값이 가장 부하가 많이 발생하는 부분이다.

=> 부하를 줄이려면 알파값을 줄이는 것이 답이다.


47. 스택에 용량제한이 있는가?
ㄴ 스택에 용량이 존재 -> 넘어가면 스택 오버플로우 발생 -> 최대 용량 : 약 1Mb
ㄴ 보통 함수가 들어가는데 함수또한 비트로 구성되어있기 때문에 1Mb 용량이면 충분하다.


48. 힙에 용량제한이 있는가? -> 언어 + OS 질문
ㄴ 메모리 풀은 하드웨어 메모리의 영향을 받는다 -> 용량에 제한이 있다.
ㄴ 어디까지 쓸수 있을까? -> OS가 허용하는 범주내까지 사용가능하다.
	ㄴ 공용공간이기 때문에 힙에 할당하기 전에 확인 필요

-> 반복문을 돌다가 가용메모리를 벗어나면 컴퓨터가 사용하고 있는 메모리를 빼서 나눠준다
	OS가 쓰는 메모리조차 다주면 다른 하드웨어에서 쓸수 있는 메모리가 있나 확인함
	(GPU는 힙과 전혀관계가 없기떄문에 해당안됨)
	CPU 한테 연산속도를 줄이라고 OS가 명령
	그래도 부족하면 가상스페이스를 만들어서 하드쪽에 데이터를 넘겨줌 (1Gb, 임시공간)
	가상스페이스로도 부족하면 가상메모리를 만들어서 넘겨주다가 마지막에 죽음
	-> selfkill -> 블루스크린이 뜨면서 끝남














