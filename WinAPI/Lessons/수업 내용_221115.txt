#include "Stdafx.h"

//==============
// # 전역 변수 #
//==============
HINSTANCE _hInstance;
HWND _hWnd;
POINT _ptMouse = { 0, 0 };

//=================
// # 함수 전방선언 #
//=================
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
void setWindowSize(int x, int y, int width, int height);

/*
int WINAPI _tWinMain(HINSTANCE hInstance,
					 HINSTANCE hPrevInstance,
					 TCHAR*    lpszCmdParam,
					 int       nCmdShow)
{
}
*/

int centerX;
int centerY;

// 윈도우 메인함수
int APIENTRY WinMain(HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
	LPSTR     lpszCmdParam,
	int       nCmdShow)
{
	// 해당되는 인스턴스를 전역변수에 담는다. 확장성 염두.
	_hInstance = hInstance;

	// 윈도우창 구조체 선언 및 초기화
	WNDCLASS wndClass; // 클래스 구조체 EXW 
	wndClass.cbClsExtra = 0;                                     // 클래스 여분 메모리
	wndClass.cbWndExtra = 0;                                     // 윈도우 여분 메모리
	wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);// 백그라운드
	wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);              // 마우스 커서
	wndClass.hIcon = LoadIcon(NULL, IDI_APPLICATION);            // 아이콘
	wndClass.hInstance = hInstance;                              // 윈도우를 소요한 프로그램의 식별자 정보
	wndClass.lpfnWndProc = (WNDPROC)WndProc;                     // 윈도우 프로시져
	wndClass.lpszClassName = WIN_NAME;							 // 클래스 이름 (윈도우 클래스 식별자)
	wndClass.lpszMenuName = NULL;                                // 메뉴 이름
	wndClass.style = CS_HREDRAW | CS_VREDRAW;                    // 윈도우 스타일 (윈도우 다시 그리기 정보)

	// 윈도우 클래스 등록
	RegisterClass(&wndClass);

	// 화면에 보여줄 윈도우 창 생성
	_hWnd = CreateWindow
	(
		WIN_NAME,                             // 윈도우 클래스 식별자
		WIN_NAME,                             // 윈도우 타이틀 바 이름
		WINSTYLE,							  // 윈도우 스타일
		WINSTART_X,                           // 윈도우 화면 X좌표
		WINSTART_Y,						      // 윈도우 화면 Y좌표
		WINSIZE_X,                            // 윈도우 화면 가로크기
		WINSIZE_Y,                            // 윈도우 화면 세로크기
		NULL,                                 // 부모 윈도우 GetDesktopWindow()
		(HMENU)NULL,                          // 메뉴 핸들
		hInstance,                            // 인스턴스 지정
		NULL                                  // 윈도우의 자식 윈도우를 생성하면 지정하고 아니라면 NULL
									    	  //  ㄴ 필요에 의해 사용하지만 지금은 NULL
	);

	// 클라이언트 영역의 사이즈를 정확히 잡는다.
	setWindowSize(WINSTART_X, WINSTART_Y, WINSIZE_X, WINSIZE_Y);

	// 1-4. 화면에 윈도우창 보여주기
	ShowWindow(_hWnd, nCmdShow);

	//UpdateWindow(_hWnd);

	// MSG: 운영체제에서 발생하는 메세지 정보를 저장하기 위한 구조체
	MSG message;
	//ZeroMemory(&msg, sizeof(msg));

	// 2. 메시지 루프

	/*
	게임용: PM_REMOVE는 정수 1을 16진수로 변경시켜 놓은 것. 속도를 위해서!
	PeekMessage는 소통 메시지가 없어도 계속 확인을 하는 것.
	GetMessage는 소통 메시지가 없으면 확인을 안 함.

	while (true)
	{
		if (PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			if (message.message == WM_QUIT) break;
			TranslateMessage(&message);
			DispatchMessageW(&message);
		}
	}
	*/

	// 일반 프로그래밍용

	while (GetMessage(&message, 0, 0, 0))
	{
		TranslateMessage(&message);
		DispatchMessage(&message);
	}

	return message.wParam;
}

// 윈도우 프로시저
// 원래는 프로시저를 직접 드러내놓고 사용하지 않음. 예외처리와 PCH, 은닉화(+대리자)를 사용.
LRESULT CALLBACK WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	HDC hdc;            // 핸들 DC. HDC는 GDI 안에 있는 것. GDI는 bmp를 사용. 행렬 연산 불가.
						// GDI+는 bmp, png 사용 가능. 회전 행렬 함수도 있음.
						// 다만, png를 사용하면 무압축 이미지를 써서 프레임 망가짐. 최적화 예외처리가 필요.
						// GDI+ 이후에 D2D가 나옴. 위 모든 기능 포함. 다만, 어려움.

	PAINTSTRUCT ps;     // 페인트 구조체

	static POINT pt  = {0,0};
	char strPT[128];

	char str[] = "그래";

	// RECT는 사각형용 구조체. RECT 방향 수정 불가.
	RECT rc = { 100, 100, 200, 200 };

	switch (iMessage)
	{

	case WM_CREATE:


		break;

	case WM_PAINT:
		hdc = BeginPaint(hWnd, &ps);

		// wsprintf(): 숫자를 문자열로 출력할 때 사용한다.
		wsprintf(strPT, "X: %d     Y: %d", pt.x, pt.y);
		TextOut(hdc, 10, 10, strPT, strlen(strPT));

		Rectangle(hdc, centerX, centerY, 100, 100);

		EndPaint(hWnd, &ps);
		break;

	case WM_MOUSEMOVE:

		pt.x = LOWORD(lParam);
		pt.y = HIWORD(lParam);

		InvalidateRect(hWnd, NULL, true);

		break;

	case WM_LBUTTONDOWN:

		centerX = RND->getInt(WINSIZE_X);
		centerY = RND->getInt(WINSIZE_Y);

		InvalidateRect(hWnd, NULL, true);

		break;


	case WM_RBUTTONDOWN:
		break;



	case WM_KEYDOWN:
		switch (wParam)
		{
		case VK_LEFT:
			break;

		case VK_RIGHT:
			break;

		case VK_ESCAPE:
			PostMessage(hWnd, WM_DESTROY, 0, 0);
			break;
		}
		break;

	case WM_DESTROY:                // 소멸자
		/*
		PostQuitMessage 함수는 메시지 큐에 Quit 메시지를 보내는 역할을 한다.
		즉, Quit 메시지를 수신하는 순간 GetMessage 함수가 FALSE를 반환함으로서
		메시지 루프가 종료된다.
		*/
		PostQuitMessage(0);
		return 0;

	}

	// 윈도우 프로시저에서 처리되지 않은 나머지 메시지를 처리해준다.
	// 윈도우 프로시저는 윈도우에 의해 호출되는 함수(콜백 함수). 메시지 전달자의 역할만 함.
	return (DefWindowProc(hWnd, iMessage, wParam, lParam));
}

void setWindowSize(int x, int y, int width, int height)
{
	RECT rc = { 0, 0, width, height };

	// 실제 윈도우 크기 조정
	// AdjustWindowRect(): 대상 객체, 사용할 윈도우 스타일, 메뉴 여부
	AdjustWindowRect(&rc, WINSTYLE, false);

	// 얻어온 렉트의 정보로 윈도우 사이즈 세팅
	SetWindowPos(_hWnd, NULL, x, y,
				 (rc.right - rc.left)
				 ,(rc.bottom - rc.top)
				 ,SWP_NOZORDER | SWP_NOMOVE);
	// SWP_NOZORDER: 다른 창에 가려졌을 때 어떻게 처리할 것인지 여부.
	// 나무 뒤에 있을 때 나무 반투명 처리 등.
}










#pragma once

#pragma region 디자인 패턴 + 싱글톤
/*
	▶ 디자인 패턴

	 - 객체지향 프로그래머 설계 단계에서 자주 발생하는 or 알려진 문제들을 피하기 위해 사용하는
	   패턴을 의미한다.


	 ▷ 장점

	  1. 의사소통 간결화로 효율 증가 (작업 속도 Up)
	   ㄴ ex) "우리 이번에 작업해야 할 기능 데코레이터로 처리합시다."

	  2. 평준화 되고 안정적인 코드 동작성
	   ㄴ 많은 프로그래머가 이미 동일한 증상을 겪어보았기 때문에 시간이 지남에 따라 해결 방안도
	      대부분 나온 상태.

	  3. 프로그래밍을 작성하는데 있어 디자인 타임에서의 다양한 상황에 대한 가이드 및 방향성 제시.
	   ㄴ 경험이 부족하다 하더라도 이미 어느정도의 효율이 보장된 디자인 패턴을 사용하면 좋다.


	 ▷ 단점

	  1. 디자인 패턴은 코드를 설계하고 작성하는 하나의 방법일 뿐 패턴병 조심.

	  2. 대부분의 디자인 패턴을 원본 부분과 활용 부분이 나뉘어져 있기 때문에
	     코드 강결화를 생각한다면 고민이 필요.


	▶ 싱글톤

	 - 프로젝트 전체에서 한 개만 존재해야 하는 객체나 클래스, 또는 프로젝트 전체에서 공유하는
	   클래스에 적용할 수 있는 패턴.


	 ▷ 장점

	  1. 한 번의 new를 통해서 객체를 생성하면 만약 프로젝트 어느곳에서도 사용하지 않고 있다면
	     인스턴스를 생성하지 않기 때문에 메모리 낭비를 방지할 수 있다. 템플릿의 장점.


	 ▷ 단점

	  1. 싱글톤은 대부분 전역변수로 처리하는 경우가 많기 때문에 코드에 대해 알아보기가 어려워지는
	     상황이 생길 수 있다.

	  2. 싱글톤 인스턴스에게 너무 많은 데이터가 공유된다면 결합도가 높아져 유지보수가 힘들다.
*/
#pragma endregion

template <class T>
class SingletonBase
{
protected:
	// 싱글톤 인스턴스 선언
	static T* singleton;

	SingletonBase() {}
	~SingletonBase() {}

public:
	// 싱글톤 가져오기
	static T* getSingleton(void);
	// 싱글톤 메모리에서 해제
	void releaseSingleton(void);
};

// 싱글톤 초기화
template <typename T>
T* SingletonBase<T>::singleton = 0;

// 싱글톤 가져오기
template <typename T>
T* SingletonBase<T>::getSingleton(void)
{
	// 싱글톤 없으면 새로 생성
	if (!singleton) singleton = new T;

	return singleton;
}

// 싱글톤 메모리 해제
template <typename T>
void SingletonBase<T>::releaseSingleton(void)
{
	// 싱글톤이 있다면 메모리에서 해제
	if (singleton)
	{
		delete singleton;
		singleton = 0;
	}
}










#pragma once
#include "SingletonBase.h"

class RandomFunction : public SingletonBase <RandomFunction>
{
public:
	RandomFunction()
	{
		// API 공용 함수
		// GetTickCount(): API 함수로 OS가 부팅된 후의 경과 시간을 체크.
		//  ㄴ 밀리세컨 단위로 체크가 가능하며 밀리세컨 단위로 시간값을
		//     반환하기 때문에 규모가 크지 않은 난수에 좋다.
		srand(GetTickCount());
	}
	~RandomFunction() {}

	inline int getInt(int num)
	{
		return rand() % num;
	}

	inline int getFromIntTo(int fromNum, int toNum)
	{
		return rand() % (toNum - fromNum + 1) + fromNum;
	}

	inline float getFloat(void)
	{
		return (float)rand() / (float)RAND_MAX;
	}

	inline float getFloat(float num)
	{
		return (float)rand() / (float)RAND_MAX * num;
	}

	inline float getFromFloatTo(float fromNum, float toNum)
	{
		float rnd = (float)rand() / (float)RAND_MAX;
		return (rnd * (toNum - fromNum) + fromNum);
	}
};