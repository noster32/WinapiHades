#include <Windows.h>
#include <tchar.h>

// 전역 변수
HINSTANCE _hInstance;

// 윈도우 핸들: 윈도우 창
HWND _hWnd;

LPTSTR _lpszClass = TEXT("Windows API");

// 콜백
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);

/*
hInstance: 프로그램 인스턴스 핸들
hPrevInstance: 이전에 실행된 인스턴스 핸들
lpszCmdParam: 명령형으로 입력된 프로그램 인수(자)
nCmdShow: 프로그램이 시작될 형태 (최소화 or 보통 크기 등)
*/

/* 이게 맞다.
int WINAPI _tWinMain(HINSTANCE hInstance,
					 HINSTANCE hPrevInstance,
					 TCHAR*    lpszCmdParam,
					 int       nCmdShow)
{

}
*/

// 윈도우 메인함수
int APIENTRY WinMain(HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
	LPSTR     lpszCmdParam,
	int       nCmdShow)
{
	// 해당되는 인스턴스를 전역변수에 담는다. 확장성 염두.
	_hInstance = hInstance;

	/*
	▶ WinMain의 역할

	1. 윈도우 창을 셋팅 후 화면에 띄우기
		ㄴ 화면에 창을 띄우기 위해서는 4가지를 모두 처리해야 한다.

	2. 메세지 루프
	*/

	// 1-1. 윈도우창 구조체 선언 및 초기화
	WNDCLASS wndClass; // 클래스 구조체 EXW 
	wndClass.cbClsExtra = 0;                                        // 클래스 여분 메모리
	wndClass.cbWndExtra = 0;                                        // 윈도우 여분 메모리
	wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);  // 백그라운드
	wndClass.hCursor = LoadCursor(NULL, IDC_ARROW);                 // 마우스 커서
	wndClass.hIcon = LoadIcon(NULL, IDI_APPLICATION);               // 아이콘
	wndClass.hInstance = hInstance;                                 // 윈도우를 소요한 프로그램의 식별자 정보
	wndClass.lpfnWndProc = (WNDPROC)WndProc;                        // 윈도우 프로시져
	wndClass.lpszClassName = _lpszClass;                            // 클래스 이름 (윈도우 클래스 식별자)
	wndClass.lpszMenuName = NULL;                                   // 메뉴 이름
	wndClass.style = CS_HREDRAW | CS_VREDRAW;                       // 윈도우 스타일 (윈도우 다시 그리기 정보)

	// 1-2. 윈도우 클래스 등록
	RegisterClass(&wndClass);

	// 1-3. 화면에 보여줄 윈도우 창 생성
	_hWnd = CreateWindow
	(
		_lpszClass,                                // 윈도우 클래스 식별자
		_lpszClass,                                // 윈도우 타이틀 바 이름
		WS_OVERLAPPEDWINDOW,                       // 윈도우 스타일
		400,                                       // 윈도우 화면 X좌표
		100,                                       // 윈도우 화면 Y좌표
		800,                                       // 윈도우 화면 가로크기
		800,                                       // 윈도우 화면 세로크기
		NULL,                                      // 부모 윈도우 GetDesktopWindow()
		(HMENU)NULL,                               // 메뉴 핸들
		hInstance,                                 // 인스턴스 지정
		NULL                                       // 윈도우의 자식 윈도우를 생성하면 지정하고 아니라면 NULL
												   //  ㄴ 필요에 의해 사용하지만 지금은 NULL
	);

	// 1-4. 화면에 윈도우창 보여주기
	ShowWindow(_hWnd, nCmdShow);

	//UpdateWindow(_hWnd);

	// MSG: 운영체제에서 발생하는 메세지 정보를 저장하기 위한 구조체
	MSG message;
	//ZeroMemory(&msg, sizeof(msg));

	// 2. 메시지 루프

	/*
	게임용: PM_REMOVE는 정수 1을 16진수로 변경시켜 놓은 것. 속도를 위해서!
	PeekMessage는 소통 메시지가 없어도 계속 확인을 하는 것.
	GetMessage는 소통 메시지가 없으면 확인을 안 함.

	while (true)
	{
		if (PeekMessage(&message, NULL, 0, 0, PM_REMOVE))
		{
			if (message.message == WM_QUIT) break;
			TranslateMessage(&message);
			DispatchMessageW(&message);
		}
	}
	*/

	// 일반 프로그래밍용

	while (GetMessage(&message, 0, 0, 0))
	{
		TranslateMessage(&message);
		DispatchMessage(&message);
	}

	return message.wParam;
}

// 윈도우 프로시져
LRESULT CALLBACK WndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
	HDC hdc;            // 핸들 DC. HDC는 GDI 안에 있는 것. GDI는 bmp를 사용. 행렬 연산 불가.
						// GDI+는 bmp, png 사용 가능. 회전 행렬 함수도 있음.
						// 다만, png를 사용하면 무압축 이미지를 써서 프레임 망가짐. 최적화 예외처리가 필요.
						// GDI+ 이후에 D2D가 나옴. 위 모든 기능 포함. 다만, 어려움.

	PAINTSTRUCT ps;     // 페인트 구조체

	char str[] = "그래";

	/*
		char[]: 수정 가능.
		char*: 수정 불가.
	*/

	// RECT는 사각형용 구조체. RECT 방향 수정 불가.
	RECT rc = { 100, 100, 200, 200 };

	switch (iMessage)
	{

	case WM_CREATE:             // 생성자
		break;

		/*
		▶ WM_PAINT

		- 윈도우를 다시 그려야 할 때  발생하는 메시지

		 ㄴ 1. 윈도우가 처음 만들어졌을 때
		 ㄴ 2. 윈도우 크기를 조절할 때
		 ㄴ 3. 윈도우가 다른 윈도우에 가려졌다가 다시 보일 때
		 ㄴ 4. 함수 호출 시 : InvalidateRect, Invalidate, UpdateAllViews 등
		*/

	case WM_PAINT:              // 출력에 관한 모든 것을 담당 (문자, 그림, 도형 등 화면의 모든 것)
		hdc = BeginPaint(hWnd, &ps);

		// 픽셀 충돌로 많이 사용함. 충돌 색상 검출을 통한 방법. 정확도가 매우 높음.
		// 예외처리가 안 된 부분에서는 무조건 버그 발생 할 수 있음.
		// 1. 점 찍기. 픽셀 충돌
		SetPixel(hdc, 300, 200, RGB(255, 0, 0));

		for (int i = 0; i < 10000; i++)
		{
			SetPixel(hdc, rand() % 800, rand() % 800, RGB(rand() % 255, rand() % 255, rand() % 255));
		}

		for (int i = 0; i < 100; i++)
		{
			for (int j = 0; j < 100; j++)
			{
				SetPixel(hdc, 400 + i, 300 + j, RGB(255, i * 2, j * 2));
			}
		}

		// 선 그리기
		MoveToEx(hdc, 400, 400, NULL);
		LineTo(hdc, 200, 400);

		MoveToEx(hdc, 400, 400, NULL);
		LineTo(hdc, 200, 200);

		// 2. 원 충돌. 속도 면에서 가장 빠름. 수학적 지식이 필요하기에 면접 어필이 잘 됨. 관련 함수가 없음.
		// 탄막게임에 많이 사용. 캐릭터에는 사용하기 좋지 않음.
		// 타원으로 불가. 정원만 사용하는 것.
		Ellipse(hdc, 300, 100, 200, 200);

		// 3. ABB / OBB
		//Rectangle(hdc, 100, 100, 200, 200);
		// 값을 변수화 시키는 것이 사용하기 매우 좋음.
		Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);

			EndPaint(hWnd, &ps);

		break;

	case WM_LBUTTONDOWN:            // 마우스 왼쪽 버튼이 눌렸을 때 메시지 발생
		hdc = GetDC(hWnd);

		break;


	case WM_RBUTTONDOWN:
		break;



	case WM_KEYDOWN:                // 키보드가 눌렸을 때 메시지 발생 
		switch (wParam)
		{
		case VK_LEFT:
			break;

		case VK_RIGHT:
			break;

		case VK_ESCAPE:
			PostMessage(hWnd, WM_DESTROY, 0, 0);
			break;
		}
		break;

	case WM_DESTROY:                // 소멸자
		/*
		PostQuitMessage 함수는 메시지 큐에 Quit 메시지를 보내는 역할을 한다.
		즉, Quit 메시지를 수신하는 순간 GetMessage 함수가 FALSE를 반환함으로서
		메시지 루프가 종료된다.
		*/
		PostQuitMessage(0);
		return 0;

	}

	// 윈도우 프로시저에서 처리되지 않은 나머지 메시지를 처리해준다.
	// 윈도우 프로시저는 윈도우에 의해 호출되는 함수(콜백함수). 메시지 전달자의 역할만 함.
	return (DefWindowProc(hWnd, iMessage, wParam, lParam));
}

/*
	과제 1. 애플 로고 출력

	 - SetPixel을 이용해서 만든다.

	 - 근성 OK, 반복문 OK, 꼼수 X, 관련 함수 X.
	 
	 - 힌트: 도형 함수.


	 과제 2. 오망성 출력

	  - 오망성을 마법진처럼 만들어 온다.

	  - 양식 자유.
	  
	  - 힌트: 배열.


	 과제 3. 사각형 이동

	  - 방향키를 통해 사각형을 움직인다.

	  - 예외처리: 사각형은 화면 밖으로 나갈 수 없다.

	  - 네 방향 모두 움직임.
*/